import java_cup.runtime.*;
import java.util.*;
parser code {:
 
    String errores = "";
    Boolean has_main = false;
    Boolean first_time = true; 
    Boolean in_method = false;
    tabla ambito;
    HashMap<String,Tipo> seen_types;
    Tipo tmp_tipo;
    ArrayList<Objeto> params; // = new ArrayList<Tipo>();
 
  
    public int getline(Object info){
		 if(info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s=((java_cup.runtime.Symbol)info);
          return s.left;
      }
      return -1;
   
} 


    public void report_error(String message, Object info) {
      StringBuffer m = new StringBuffer("Error");
		 if(info instanceof java_cup.runtime.Symbol) {
			java_cup.runtime.Symbol s=((java_cup.runtime.Symbol)info);
			if(s.left >= 0) {
				m.append(" en linea "+(s.left+1));
				if (s.right >= 0)
					m.append(", y columna "+(s.right+1));
			}
		}
        message = message.replaceAll("Syntax error","Error de sintaxis");
 		    m.append(" : "+message);
 
        errores += m;
        errores += "\n";
       if(!first_time)
        System.out.println(m);
 }

    public void report_fatal_error(String message, Object info) {
          message = message.replaceAll("Couldn't repair and continue parse","No se pudo recuperar");
        	report_error(message, info);
        
		System.exit(1);
    }

    public void report_semantic_error(String error,int linea,int columna){
      System.out.println("Error semantico en la linea: "  + (linea+1) + " columna: "  + (columna+1) + "\n" + error  );
    }

:}

terminal DO, PARDER, PARIZQ, TO, AS, DIM, SEPARADOR, FIN, REF, SUB, FUNCTION;
terminal IGUAL,LOOP,IF,THEN, ELSE, ELSEIF,END,FOR,NEXT,WHILE ,NUM,TRUE,FALSE;
terminal String NAME,OPREL,TIPO,CADENA;
terminal WRITE,WRITELN,INPUT;
terminal POR,ENTRE,MAS,MENOS,ERROR,RETURN;
terminal TYPE,EXIT, PUNTO,NOT,SALTOCADENA;
non terminal String vars,cadena_s;
non terminal Tipo tipo,funcionCall;
non terminal fin;
non terminal Object statement, metodo, programa,linea, declaracion,declar_var, statements, loop_for, do_loop, if_block;
non terminal Object schrodingerArgument,asignacion,if_inner,list_declar,list_expressions,argument, argumentlist, argumentlistHelper,bloque;
non terminal Object variables_declar2,list_declar2,declaracion2,salir_param,variables_declar;
non terminal Object retorno,salir_if,end_func,end_type,regresar,dectype,paramHelper,parametros,end_sub;
non terminal Object rango,salir_loop,subfunc ,funcion;
non terminal Object fake_f,fake_s,fake_while,fake_if;

non terminal Objeto lee, escribe, termino, factor, expression, nombre;



programa ::= fin statements | statements | fin |;

fin ::= FIN fin | FIN;

statements ::= linea statements 
              |linea;


linea ::= declar_var FIN
          | metodo
          | dectype
          | error fin {: if(!parser.first_time) parser.report_error(" Se esperaba declaracion de variables, metodos o estructuras",sym.ERROR); :};


variables_declar ::= declar_var fin;


/*----declaracion de variables----*/

declar_var ::= DIM declaracion;
     
declaracion ::= vars:n1 AS tipo:t SEPARADOR declaracion  
                    {:  
                        //meter las variables globales dentro de la tabla
                        int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                        int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                        
                    if ( parser.first_time && !parser.in_method ){ boolean meter = parser.ambito.agregarATabla(n1,t );
                            if(!meter ) parser.report_semantic_error("Variable <" + n1 +  "> ya ha sido declarada en este contexto",linea,columna);
                        }
                        
                        if ( !parser.first_time && !parser.in_method ){
                            Tipo tmp = parser.ambito.BuscarEnTabla(n1);
                            Tipo extra = parser.seen_types.get(tmp.getName());
                            if(extra== null )
                            {  parser.report_semantic_error(" No existe el tipo " + t.getName() + " en la declaracion de variable " + n1,linea,columna); }
                        } 
                        if ( !parser.first_time && parser.in_method ){
                            if( parser.seen_types.get(t.getName()) == null){
                                parser.report_semantic_error("No existe el tipo" + t.getName() + " en la declaracion de la variable" + n1, linea,columna);
                            }
                            else{
                                boolean meter = parser.ambito.agregarATabla(n1,t );
                                if(!meter ) parser.report_semantic_error("Variable <" + n1 +  "> ya ha sido declarada en este contexto",linea,columna);

                            }   
                        } 
                    :} 
              | vars:n1 AS tipo:t 
                    {:  
                      int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                      int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;


                      if (parser.first_time && !parser.in_method ){boolean meter = parser.ambito.agregarATabla(n1,t ); 
                            if(!meter ) parser.report_semantic_error("Variable <" + n1 +  "> ya ha sido declarada en este contexto",linea,columna);
                        }
                        if ( !parser.first_time && !parser.in_method ){
                            Tipo tmp = parser.ambito.BuscarEnTabla(n1);
                            Tipo extra = parser.seen_types.get(tmp.getName());
                            if(extra== null )
                            {  parser.report_semantic_error(" No existe tipo " + t.getName() + " en la declaracion de variable " + n1,linea,columna); }
                        } 
                        if ( !parser.first_time && parser.in_method ){
                            if( parser.seen_types.get(t.getName()) == null){
                                parser.report_semantic_error("No existe el tipo" + t.getName() + " en la declaracion de la variable" + n1, linea,columna);
                            }
                            else{
                                boolean meter = parser.ambito.agregarATabla(n1,t );
                                if(!meter ) parser.report_semantic_error("Variable <" + n1 +  "> ya ha sido declarada en este contexto",linea,columna);
                            
                              }   
                        }
            :} 
              

          | error {: if(!parser.first_time) parser.report_error("Declaracion de variables: Se esperaba ID",sym.ERROR); :} ;




vars ::= NAME:n1 {:  RESULT = n1.toLowerCase() ; :}
        | NAME:n1 SEPARADOR vars:n2 
           {: 
              int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
              int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
          if ( parser.first_time ){ 
                  boolean meter =  parser.ambito.agregarATabla(n1.toLowerCase(),parser.seen_types.get("variant") ); 
                  if(!meter ) parser.report_semantic_error("Variable <" + n1 +  "> ya ha sido declarada en este contexto",linea,columna);
                 
                  }
              RESULT = n2.toLowerCase(); :}
        | NAME SEPARADOR error {:
              int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
              int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
             if(!parser.first_time) parser.report_semantic_error("Declaracion de variables: Se esperaba nombre",linea,columna); :};
    

  
tipo ::= TIPO:n1 {:
                     Tipo x = parser.seen_types.get(n1.toLowerCase());
                    RESULT = x;
                  :}

       | NAME:n1 {:
                   Tipo x = parser.seen_types.get(n1.toLowerCase());
                    if( x ==null)
                    {
                      x = new Tipo(n1.toLowerCase());
                    }
                    RESULT = x;   :};
/*--------------------------------*/

/*---Declaracion de metodos-------*/
metodo ::= subfunc 
         | funcion;

subfunc ::=  SUB fake_s argumentlist fin end_sub fin {: parser.ambito = parser.ambito.parent; :};


funcion ::=   FUNCTION fake_f argumentlist retorno fin end_func fin {: parser.ambito = parser.ambito.parent;  :} 
          |FUNCTION fake_f argumentlist retorno fin error fin {: if (!parser.first_time) parser.report_error("Error en el bloque de funcion",sym.ERROR); parser.ambito = parser.ambito.parent;:}
          | FUNCTION error fin {: if (!parser.first_time) parser.report_error("Se esperaba nombre de funcion",sym.ERROR); :}
          | FUNCTION fake_f error PARIZQ retorno fin end_func fin {: if (!parser.first_time) parser.report_error("error de parametros",sym.ERROR); parser.ambito = parser.ambito.parent;:}  
          | FUNCTION fake_f error fin end_func fin {: if (!parser.first_time) parser.report_error("error de parametros",sym.ERROR); parser.ambito = parser.ambito.parent; :} 
          | FUNCTION fake_f error {: if (!parser.first_time) parser.report_error("Error en firma de funcion",sym.ERROR); parser.ambito = parser.ambito.parent;  :};


fake_f ::= NAME:n1 {: if(parser.first_time){ 
                         tabla nuevo_ambito = new tabla(parser.ambito,n1);
                         parser.ambito.hijos.add(nuevo_ambito);
                         parser.ambito = nuevo_ambito;
                         parser.tmp_tipo = new Tipo(n1);
                         parser.tmp_tipo.setTipoFinal(1);
                      }
                      else{
                          
                        for(tabla t:parser.ambito.hijos)
                           {
                                if( t.ambito.equals(n1))
                                {  parser.ambito = t; 
                                    break;}
                           }
                       }
                    :};

fake_s ::= NAME:n1 {: 
                      if(parser.first_time){
                      tabla nuevo_ambito = new tabla(parser.ambito,n1); 
                      parser.ambito.hijos.add(nuevo_ambito);
                      parser.ambito = nuevo_ambito;
                      parser.tmp_tipo = new Tipo(n1);
                      parser.tmp_tipo.setTipoFinal(2);
                      if (n1.toLowerCase().equals("main")) parser.has_main = true; 
                                }
                      else{
                          for(tabla t:parser.ambito.hijos)
                           {
                                if( t.ambito.equals(n1))
                                {  parser.ambito = t; 
                                    break;}
                           }
                       }


                     :};

retorno ::=  AS TIPO:t1 {:  
                            if(parser.first_time){parser.tmp_tipo.metodo_var.add(parser.seen_types.get(t1)); 
                                  parser.seen_types.put( parser.tmp_tipo.getName(), parser.tmp_tipo);
                            }
                            else{
                                      Tipo x = parser.seen_types.get(t1.toLowerCase());
                                      parser.ambito.agregarATabla(parser.ambito.ambito, x   );
                            }
                        :}
            | error {: if (!parser.first_time) parser.report_error(" No existe tipo de retorno de funcion, se esperaba: As <Tipo>",sym.AS); :}
            | AS error {: if (!parser.first_time) parser.report_error(" Tipo de retorno invalido de funcion, se esperaba: As <char|integer|string|boolean>",sym.AS); :};
            

end_sub ::= bloque END SUB
            | END SUB
            | END error {: if (!parser.first_time) parser.report_error(" Se esperaba End Sub",sym.ERROR); :} ;

end_func ::=  bloque END FUNCTION
            | END FUNCTION
            | bloque END error {: if (!parser.first_time) parser.report_error(" Se esperaba End Function", sym.ERROR); :} ;

end_type ::=  END TYPE
            | END error {: if (!parser.first_time) parser.report_error("Se esperaba End Type",sym.ERROR); :};

regresar ::= EXIT SUB fin
            | EXIT FUNCTION fin 
            | EXIT error {: if (!parser.first_time) parser.report_error(" Salida de metodos: se esperaba Exit Sub o Exit Function",sym.ERROR); :};

/*--------------------------------*/


bloque ::= list_expressions
         | list_expressions regresar 
         | list_declar list_expressions
         | list_declar list_expressions regresar
         | list_declar
         | list_declar regresar
         | regresar ;

list_declar ::= variables_declar list_declar 
               | variables_declar;


list_expressions ::= statement list_expressions | statement ;

statement ::= if_block | loop_for | do_loop | asignacion 
              |funcionCall fin
              | escribe | lee
              | RETURN fin
              | RETURN expression fin
              | NAME error {: if (!parser.first_time) parser.report_error(" Expresion no se esperaba.",sym.ERROR); :} ;



escribe ::=   WRITE cadena_s fin
             | WRITE nombre fin
             | WRITE error {: if (!parser.first_time) parser.report_error("Se esperaba cadena o variable",sym.WRITE);:}
             | WRITELN nombre fin
             | WRITELN cadena_s fin
             | WRITELN error {: if (!parser.first_time) parser.report_error("Se esperaba cadena o variable",sym.WRITELN); :};
               
lee ::= INPUT nombre fin
      | INPUT error {: if (!parser.first_time) parser.report_error(" Se esperaba variable",sym.ERROR); :} ;

   
asignacion ::= nombre:n IGUAL expression:e fin:f {: 
            
            if(!parser.first_time)
            {

              
              if(!n.t.getName().equals(e.t.getName()) && !n.t.getName().equals("variant") )
              {
                

                if( e.t.getName().equals("variant") && e.TipoExtraVariant.getName().equals( n.t.getName() ) ){
                
                }
                else if(!( n.t.getName().equals("char") && e.t.getName().equals("string") && e.SizeChain <= 1)){
                  int left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                  int right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                  parser.report_semantic_error("No se puede asignar " +  e.t.getName() + " a variable de tipo " + n.t.getName(),left,right);       
               }      
                

                
              }
              else if( n.t.getName().equals("variant") && !e.t.getName().equals("error")){
                  parser.ambito.CambiarExtraTipo(n.id,e.t); 
                }
               
            }
              :}
              | nombre IGUAL error fin {: if (!parser.first_time) parser.report_error("No se puede asignar valor, error en expresion ",sym.ERROR); :};
            
nombre ::= NAME:n1 {:
                    int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                    if(!parser.first_time){
                      Tipo tmp = parser.ambito.BuscarEnTabla(n1);
                      if( tmp.getName().equals("error"))
                          parser.report_semantic_error("Variable " + n1 + " no fue declarada" , linea,columna);
                      RESULT = new Objeto(tmp);
                      RESULT.id = n1;
                      RESULT.TipoExtraVariant = parser.ambito.BuscarExtraTipo(n1);
                      } 
                    :} 
          | NAME:n1 PUNTO NAME:n2 {:
                      int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                      int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                      if(!parser.first_time){
                        Tipo tmp = parser.ambito.BuscarEnTabla(n1);
                         if( tmp.getName().equals("error")){
                              parser.report_semantic_error("Variable " + n1 + " no fue declarada/con punto" , linea,columna);
                              RESULT =  new Objeto(parser.seen_types.get("error"));
                        }
                        else{
                            tmp = parser.seen_types.get(tmp.getName()).atributos.get(n2);
                            if( tmp == null){
                                parser.report_semantic_error(n1 + " no cuenta con atributo " + n2,linea,columna);
                                RESULT = new Objeto(parser.seen_types.get("error"));
                            }
                            else{
                                 RESULT = new Objeto(tmp);
                            }
                          }              
                        
                        }
                    :} 
           | NAME PUNTO error {: if (!parser.first_time) parser.report_error(" Error de <id> en asignacion ",sym.ERROR); :};


expression ::= expression:e MAS termino:t 
              {: 
                int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                
                if(!parser.first_time){
                  if(e.t.getName().equals(t.t.getName()) && e.t.getName().equals("integer") ){
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  
                  }
                  else if( e.t.getName().equals(t.t.getName()) && e.t.getName().equals("variant") 
                            && e.TipoExtraVariant.getName().equals(t.TipoExtraVariant.getName()) 
                            && e.TipoExtraVariant.getName().equals("integer") ){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( e.t.getName().equals("variant") && e.TipoExtraVariant.getName().equals("integer")  && t.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( t.t.getName().equals("variant") && t.TipoExtraVariant.getName().equals("integer")  && e.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
  
                  else{

                    parser.report_semantic_error(" No se puede sumar " + e.t.getName() + " con " + t.t.getName(),linea,columna);
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                }
              :}


              | expression:e MENOS termino:t
              {: 
                int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                
                if(!parser.first_time){
                  if(e.t.getName().equals(t.t.getName()) && e.t.getName().equals("integer") ){
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  
                  }
                  else if( e.t.getName().equals(t.t.getName()) && e.t.getName().equals("variant") 
                            && e.TipoExtraVariant.getName().equals(t.TipoExtraVariant.getName()) 
                            && e.TipoExtraVariant.getName().equals("integer") ){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( e.t.getName().equals("variant") && e.TipoExtraVariant.getName().equals("integer")  && t.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( t.t.getName().equals("variant") && t.TipoExtraVariant.getName().equals("integer")  && e.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
  
                  else{

                    parser.report_semantic_error(" No se puede restar " + e.t.getName() + " con " + t.t.getName(),linea,columna);
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                }
              :}
              | termino:t {: RESULT = t; :}
              | expression:e IGUAL termino:t {: RESULT = new Objeto(parser.seen_types.get("boolean"));:};


termino ::= factor:f POR termino:t
              {: 
                int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                
                if(!parser.first_time){
                  if(f.t.getName().equals(t.t.getName()) && f.t.getName().equals("integer") ){
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  
                  }
                  else if( f.t.getName().equals(t.t.getName()) && f.t.getName().equals("variant") 
                            && f.TipoExtraVariant.getName().equals(t.TipoExtraVariant.getName()) 
                            && f.TipoExtraVariant.getName().equals("integer") ){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( f.t.getName().equals("variant") && f.TipoExtraVariant.getName().equals("integer")  && t.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( t.t.getName().equals("variant") && t.TipoExtraVariant.getName().equals("integer")  && f.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
  
                  else{

                    parser.report_semantic_error(" No se puede multiplicar " + f.t.getName() + " con " + t.t.getName(),linea,columna);
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                }
              :}


          | factor:f ENTRE termino:t
              {: 
                int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                
                if(!parser.first_time){
                  if(f.t.getName().equals(t.t.getName()) && f.t.getName().equals("integer") ){
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  
                  }
                  else if( f.t.getName().equals(t.t.getName()) && f.t.getName().equals("variant") 
                            && f.TipoExtraVariant.getName().equals(t.TipoExtraVariant.getName()) 
                            && f.TipoExtraVariant.getName().equals("integer") ){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( f.t.getName().equals("variant") && f.TipoExtraVariant.getName().equals("integer")  && t.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                  else if( t.t.getName().equals("variant") && t.TipoExtraVariant.getName().equals("integer")  && f.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
  
                  else{

                    parser.report_semantic_error(" No se puede dividir " + f.t.getName() + " con " + t.t.getName(),linea,columna);
                    RESULT = new Objeto(parser.seen_types.get("integer"));
                  }
                }
              :}

          | factor:f OPREL termino:t 
              {: 
                int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                
                if(!parser.first_time){
                  if(f.t.getName().equals(t.t.getName()) && f.t.getName().equals("integer") ){
                    RESULT = new Objeto(parser.seen_types.get("boolean"));
                  
                  }
                  else if( f.t.getName().equals(t.t.getName()) && f.t.getName().equals("variant") 
                            && f.TipoExtraVariant.getName().equals(t.TipoExtraVariant.getName()) 
                            && f.TipoExtraVariant.getName().equals("integer") ){
                        RESULT = new Objeto(parser.seen_types.get("boolean"));
                  }
                  else if( f.t.getName().equals("variant") && f.TipoExtraVariant.getName().equals("integer")  && t.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("boolean"));
                  }
                  else if( t.t.getName().equals("variant") && t.TipoExtraVariant.getName().equals("integer")  && f.t.getName().equals("integer")){
                        RESULT = new Objeto(parser.seen_types.get("boolean"));
                  }
  
                  else{

                    parser.report_semantic_error(" No se puede comparar " + f.t.getName() + " con " + t.t.getName(),linea,columna);
                    RESULT = new Objeto(parser.seen_types.get("boolean"));
                  }
                }
              :}
          | factor:f {: RESULT = f; :};
        

factor ::= PARDER expression:e PARIZQ {: RESULT = e; :}
        | NOT factor:f1 {: 
                            int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                            int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                            
                            if(!parser.first_time){ 
                              if( f1.t.getName().equals("variant" ) && f1.TipoExtraVariant.getName().equals("boolean")){  
                                RESULT = new Objeto(parser.seen_types.get("boolean"));
                              }
                              else if(!f1.t.getName().equals("boolean")  ) 
                                  parser.report_semantic_error("Tipo no booleano en expresion",linea,columna);
                                RESULT = new Objeto(parser.seen_types.get("boolean")); 
                               //RESULT = f1;  
                            }
                            else{
                                RESULT = f1;    

                            }
                        :}

        | NUM {: RESULT = new Objeto(parser.seen_types.get("integer")); :}
        | nombre:n {: RESULT = n; :}
        | TRUE {: RESULT=  new Objeto(parser.seen_types.get("boolean")); :}
        | FALSE {: RESULT= new Objeto(parser.seen_types.get("boolean")); :}
        | cadena_s:s {: Objeto t = new Objeto(parser.seen_types.get("string")); 
                      String fin = "";
                      for(char c:s.toCharArray()){
                        if( c != '"')
                           fin += c;
                      }
                    t.SizeChain= fin.length();
                      RESULT = t;:}
        | funcionCall:f {:  RESULT = new Objeto(f); :};

cadena_s ::= CADENA:c SALTOCADENA fin cadena_s:sig {: RESULT = c + sig;  :}
            |CADENA:c {:
                      RESULT = c; :}
            |CADENA SALTOCADENA error {: if (!parser.first_time) parser.report_error("Se esperaba nueva cadena",sym.ERROR); :}; 
       
 
funcionCall ::= NAME:n1 PARDER {: if(!parser.first_time) parser.params = new ArrayList<Objeto>();:} parametros
       {:
             int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
             int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                if(!parser.first_time){

               boolean valido = true;
                Tipo tmp = parser.seen_types.get(n1);
                if(tmp == null){
                      parser.report_semantic_error(" No existe metodo con nombre " + n1 ,linea,columna);
                      RESULT = parser.seen_types.get("error");
                }
                else{
                  if (tmp.metodo_var.size() -1 != parser.params.size()){
                    parser.report_semantic_error(" Error de argumentos,se esperaban: " + (tmp.metodo_var.size() -1) + " recibidos:" + parser.params.size(),linea,columna); 
                  }
                  else{
                    for( int i = 0; i < parser.params.size();i++){
                            if(!parser.params.get(i).t.getName().equals(tmp.metodo_var.get(i).getName())){
                              if( tmp.metodo_var.get(i).getName().equals("char") && parser.params.get(i).t.getName().equals("string"))   {
                                 if ( parser.params.get(i).SizeChain <= 1)
                                    continue;
                              }
                              parser.report_semantic_error(" Error de argumento " + i + " se esperaba " +  tmp.metodo_var.get(i).getName() + " recibio " + parser.params.get(i).t,linea,columna);
                          }
                    }
                  }
                  
                   RESULT = tmp.metodo_var.get( tmp.metodo_var.size()-1);
                }
          }
            :} ;
               
parametros ::= expression:e   {: if(!parser.first_time)parser.params.add(e);
                   :} paramHelper
              | salir_param;

paramHelper ::= SEPARADOR expression:e {:if(!parser.first_time)parser.params.add(e); :} paramHelper
              | salir_param;

salir_param ::= PARIZQ; // | error {: if (!parser.first_time) parser.report_error("Se esperaba )",sym.ERROR); :}; 


/*---Declaracion de argumentos ---*/



argumentlist ::= PARDER schrodingerArgument;


schrodingerArgument ::= argument argumentlistHelper
                      | PARIZQ
                      | error {: if (!parser.first_time) parser.report_error("error de argumentos",sym.ERROR); :}; 


argumentlistHelper ::= SEPARADOR argument argumentlistHelper 
                      | PARIZQ
                      |error PARIZQ {: if (!parser.first_time) parser.report_error("error de argumentos",sym.ERROR); :}; 

argument ::= REF NAME:n1 AS tipo:t {:
                                      if(parser.first_time){ 
                                          parser.ambito.agregarATabla(n1,t);
                                          parser.tmp_tipo.metodo_var.add(t);
                                        }
                                    :}
            | REF NAME AS error {: if (!parser.first_time) parser.report_error(" error en argumento, se esperaba un tipo de dato",sym.ERROR); :}
            | REF NAME  error {: if (!parser.first_time) parser.report_error(" error en argumento, se esperaba As <un tipo de dato>",sym.ERROR); :}
            
            | REF error AS tipo {: if (!parser.first_time) parser.report_error(" error en argumento, no existe nombre de argumento",sym.NAME); :} 
            | error NAME AS tipo{: if (!parser.first_time) parser.report_error("error en argumento, no existe tipo de referencia",sym.ERROR); :};




/*---if-----*/
//Ya revisado, bexpression es lo que hay que ver

if_block ::= IF fake_if THEN fin bloque if_inner
            |IF fake_if fin bloque if_inner
            |IF fake_if THEN fin if_inner
            |IF fake_if fin if_inner
            |IF error fin if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            |IF error THEN fin if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            |IF error fin bloque if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            |IF error THEN fin bloque if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :};
      


if_inner ::= salir_if fin
            | ELSE fin bloque salir_if fin
            | ELSE fin salir_if fin
            | ELSE error {: if (!parser.first_time) parser.report_error("Error en expresion Else",sym.ERROR); :}  
            | ELSEIF fake_if fin bloque if_inner
            | ELSEIF fake_if THEN fin bloque if_inner
            | ELSEIF fake_if fin if_inner
            | ELSEIF fake_if THEN fin if_inner
            | ELSEIF error fin if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            | ELSEIF error THEN fin if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            | ELSEIF error fin bloque if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            | ELSEIF error THEN fin bloque if_inner {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            | ELSE fin error salir_if fin {: if (!parser.first_time) parser.report_error("Sentencia inesperada despues del Else",sym.ERROR); :}
            | error salir_if{: if (!parser.first_time) parser.report_error("Error del bloque if, sentencia no esperada",sym.ERROR); :};

salir_if ::= END IF
            | END error {:if (!parser.first_time) parser.report_error("Se esperaba End If",sym.ERROR); :};
        
/*--- do y for --*/


fake_while ::= expression:e {:

                    int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
                    int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;

                if(!parser.first_time){
                  if(!e.t.getName().equals("boolean") ){
                      parser.report_semantic_error("Se esperaba expression booleana dentro de ciclo while",linea,columna);
                  }
                }              
  
              :};

fake_if ::= expression:e {:
              int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
              int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                if(!parser.first_time){
                  if(!e.t.getName().equals("boolean")){
                      if(!( e.t.getName().equals("variant") && e.TipoExtraVariant.getName().equals("boolean")))
                         parser.report_semantic_error("Se esperaba expression booleana dentro del If",linea,columna);
                  }
                }              
  
              :};



do_loop ::= DO WHILE fake_while fin bloque salir_loop
            | DO WHILE fake_while fin salir_loop
            
            | DO error fake_while fin bloque salir_loop {: if (!parser.first_time) parser.report_error("Se esperaba While <expresion booleana> ",sym.ERROR); :}
            | DO error fake_while fin salir_loop {: if (!parser.first_time) parser.report_error("Se esperaba While <expresion booleana> ",sym.ERROR); :}
            | DO WHILE error fin salir_loop {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :}
            | DO WHILE error fin bloque salir_loop {: if (!parser.first_time) parser.report_error("Se esperaba expresion booleana",sym.ERROR); :};

 
salir_loop ::= LOOP fin
              |error {: if (!parser.first_time) parser.report_error("se esperaba salida de while",sym.ERROR); :};

loop_for ::= FOR rango fin bloque NEXT fin
            | FOR rango fin NEXT fin
            | FOR error fin NEXT fin {: if (!parser.first_time) parser.report_error("Error en rango",sym.ERROR); :}
            | FOR error fin bloque NEXT fin {: if (!parser.first_time) parser.report_error("Error en rango",sym.ERROR); :}
            | FOR rango fin error {: if (!parser.first_time) parser.report_error("Se esperaba un Next",sym.NEXT); :}
            | FOR rango fin bloque error {: if (!parser.first_time) parser.report_error("Se esperaba un Next",sym.NEXT); :}; 
    
rango ::= NAME IGUAL expression:t1 TO expression:t2 
          {:
               int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
               int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
                
              if(!parser.first_time){
                  if( !t1.t.getName().equals("integer") )
                      parser.report_semantic_error("Rango no numerico en expression inicial",linea,columna);
                  if( !t2.t.getName().equals("integer"))
                      parser.report_semantic_error("Rango no numerico en expression inicial",linea,columna);
              }

          :}
        | NAME IGUAL TO error {: if (!parser.first_time) parser.report_error("Error de rangos, no existe valor inicial",sym.ERROR); :}
        | NAME IGUAL error TO {: if (!parser.first_time) parser.report_error("Error de rangos, valor inicial y final",sym.ERROR); :} 
        | NAME IGUAL error {: if (!parser.first_time) parser.report_error("Error de rangos/asignacion",sym.ERROR); :} 
        | NAME IGUAL error TO error {: if (!parser.first_time) parser.report_error("Error de rangos",sym.ERROR); :}
        | NAME IGUAL expression TO error {: if (!parser.first_time) parser.report_error("Se esperaba valor de final",sym.ERROR); :}
        | NAME IGUAL error TO expression {: if (!parser.first_time) parser.report_error("Se esperaba valor de inicio",sym.ERROR); :}

; 

/*---- estructuras ---*/



              
dectype ::= TYPE NAME:n1  fin {: if(parser.first_time) {parser.tmp_tipo = new Tipo(n1); parser.tmp_tipo.setTipoFinal(3);} :} list_declar2 end_type fin
                              {: if(parser.first_time) {parser.seen_types.put(n1,parser.tmp_tipo);
                                                        } :}
          | TYPE NAME error end_type fin {: if(!parser.first_time) parser.report_error(" estructura no puede estar vacia",sym.ERROR); :} ;


list_declar2 ::= variables_declar2 list_declar2 
               | variables_declar2;

variables_declar2 ::= declaracion2 fin;

declaracion2 ::= DIM NAME:n1 AS tipo:t1 {: 
              int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
              int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;

              if(parser.first_time){ 
                      boolean meter = parser.tmp_tipo.agregar_atributos(n1,t1);
                      if(!meter) parser.report_semantic_error("No se puede agregar atributo de nombre " + n1 + " ya existe en este contexto",linea,columna);
                                      }  :}
                | NAME:n1 AS tipo:t1 {: 
              int linea = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
              int columna = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;

                if( parser.first_time) {
                                      boolean meter =parser.tmp_tipo.agregar_atributos(n1,t1);
                                     if(!meter) parser.report_semantic_error("No se puede agregar atributo de nombre " + n1 + " ya existe en este contexto",linea,columna);
                      
                   }
        :}
                | error {: if(!parser.first_time) parser.report_error("Se esperaba <id> As <tipo> ",sym.ERROR); :};


